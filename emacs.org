#+TITLE: Eight Megabytes And Constantly Swapping
#+PROPERTY: header-args: emacs-lisp :lexical t
#+PROPERTY: header-args+ :cache yes :comments yes :mkdirp yes :results silent
#+PROPERTY: header-args+ :tangle (expand-file-name "init.el" user-emacs-directory)
#+PROPERTY: header-args+ :tangle-mode (identity #o644)

To install, open this file in *Emacs 29+* & evaluate the code block below by
placing the cursor in between the =#+begin_src= & =#+end_src= lines and
pressing =C-c C-c=.

#+begin_src emacs-lisp :tangle no
  (org-babel-tangle) (load (expand-file-name "init.el" user-emacs-directory))
#+end_src

This will "tangle" all the code blocks below /(that don't live under a heading
that starts with =COMMENT=)/ into =~/.emacs.d/init.el= and then compile &
evaluate it.

To un/comment a heading - move the point to the heading and press =C-c ;=.

#+begin_src emacs-lisp :comments no
  ;; -*- lexical-binding: t; -*-
#+end_src

* EMACS

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (column-number-mode)
    (display-battery-mode)
    (display-time)
    (electric-pair-mode)
    (global-subword-mode)
    (global-prettify-symbols-mode)
    (save-place-mode 1)
    :custom
    (c-default-style "bsd")
    (auto-save-visited-mode t)
    (completion-styles '(basic substring initials flex))
    (custom-file (expand-file-name "custom.el" user-emacs-directory))
    (disabled-command-function nil)
    (display-time-default-load-average 'nil)
    (display-time-format "%H:%M %a %d/%m")
    (fill-column 79)
    (when (executable-find "fd") find-program "fd")
    (when (executable-find "rg") grep-program "rg")
    ;; (mac-command-modifier 'control)
    ;; (mac-control-modifier 'super)
    (package-archives
     '(("gnu" . "https://elpa.gnu.org/packages/")
       ("melpa" . "https://melpa.org/packages/")
       ("nongnu" . "https://elpa.nongnu.org/nongnu/")))
    (savehist-additional-variables '(compile-command kill-ring register-alist))
    ;; https://emacs.stackexchange.com/a/78660
    (tramp-allow-unsafe-temporary-files t)
    (use-package-always-defer t)
    (use-package-enable-imenu-support t)
    (use-short-answers t)
    :config
    (if (eq system-type 'darwin)
	    (setq default-frame-alist '((fullscreen . fullscreen)))
      (setq default-frame-alist '((fullscreen . maximized))))
    (setq roland "YOU HAVE FORGOTTEN THE FACE OF YOUR FATHER")
    :bind
    ;; USE CTRL-I FFS or the sake of your pinkies!
    ("<tab>" . (lambda () (interactive) (message roland)))
    ;; USE CTRL-J/M FFS or the sake of your pinkies!
    ("<return>" . (lambda () (interactive) (message roland)))
    ;; USE CTRL-H FFS or the sake of your pinkies!
    ("<backspace>" . (lambda () (interactive) (message roland)))
    ("C-h" . backward-delete-char-untabify) ;; act the same as terminal
    ("C-M-h" . backward-kill-word) ;; ditto! Also M-h seems to do the same
    ("C-c h" . 'help-command) ;; We don't always have F1 as a fallback...
    ("C-c f r" . rename-visited-file)
    ("C-c a" . align-regexp)
    ("C-c i" . imenu)
    ("C-c m" . compile)
    ("C-c b" . browse-url-at-point)
    ("C-c p" . proced)
    ("C-s-f" . toggle-frame-fullscreen)
    ("C-x C-b" . ibuffer)
    ("C-x m" . man)
    ("C-x x s" . sort-lines)
    ("C-x M-k" . kill-buffer)
    ("C-x M-c" . kill-emacs) ;; for killing the daemon
    ("C-x k" . (lambda () (interactive) (kill-buffer (current-buffer))))
    (:map minibuffer-local-must-match-map
	      ("C-s" . minibuffer-next-completion)
	      ("C-r" . minibuffer-previous-completion)
	      ("C-n" . next-history-element)
	      ("C-p" . previous-history-element)))
#+end_src

* BINDINGS

Override at a global level some clunky defaults. The =*= used with
=bind/bindkey= stops minor modes from clobbering.

I have my ctrl keys next to my space bar so it's much more comfortable than
meta/alt. Also avoid shifting for frequently used shortcuts if it can be
helped.

*N.B.* =bind*= doesn't work within the =emacs= "package" using =use-package= as
obviously Emacs is not a package!

#+begin_src emacs-lisp
  (bind-key* "C-&" 'async-shell-command)
  (bind-key* "C-!" 'shell-command)
  (bind-key* "C-$" 'aspell-word)
  (bind-key* "C-%" 'query-replace-regexp)
  (bind-key* "C-*" 'duplicate-line)
  (bind-key* "C-," 'beginning-of-buffer)
  (bind-key* "C-." 'end-of-buffer)
  (bind-key* "C-;" 'comment-line)
  (bind-key* "C-M-;" 'comment-box)
  (bind-key* "C-=" 'global-text-scale-adjust)
  (bind-key* "C-^" 'copy-from-above-command)
  (bind-key* "C-z" 'zap-up-to-char)
#+end_src

* DEFUNS

All of my custom functions live under the =my/= prefix/namespace.

** delete-inside-delimiters

#+begin_src emacs-lisp
  (defun my/delete-inside-delimiters (arg)
    "Deletes the text within parentheses, brackets or quotes. With prefix
  ARG, delete delimiters too."
    (interactive "P")
    ;; Search for a match on the same line, don't delete across lines
    (search-backward-regexp "[[{(<\"\']" (line-beginning-position))
    (forward-char)
    (let ((lstart (point)))
      (search-forward-regexp "[]})>\"\']" (line-end-position))
      (backward-char)
      (if arg
	  (kill-region (- lstart 1) (+ (point) 1))
	(kill-region lstart (point)))))

  (keymap-global-set "C-c d" 'my/delete-inside-delimiters)
#+end_src

** delete-this-file

#+begin_src emacs-lisp
  (defun my/delete-this-file ()
    "Delete the current file, and kill the buffer."
    (interactive)
    (or (buffer-file-name) (error "No file is currently being edited"))
    (when (yes-or-no-p (format "Really delete '%s'?"
			       (file-name-nondirectory buffer-file-name)))
      (delete-file (buffer-file-name) t)
      (kill-this-buffer)))

  (keymap-global-set "C-c f d" 'my/delete-this-file)
#+end_src

** indent-buffer

#+begin_src emacs-lisp
  (defun my/indent-buffer ()
    "Indent the contents of a buffer."
    (interactive)
    (indent-region (point-min) (point-max)))

  (keymap-global-set "M-i" 'my/indent-buffer)
#+end_src

** init-frame

Otherwise emacsclient doesn't initialise UI settings.

#+begin_src emacs-lisp
  (defun my/init-frame (frame)
    "Initialize frame UI, and settings that don't work unless they're set
  after emacsclient has created a frame"
    (select-frame frame)

    (if window-system (load-theme 'modus-vivendi))

    (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
    (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
    (if (fboundp 'tooltip-mode) (tooltip-mode -1))

    (when (not (eq system-type 'darwin)) (menu-bar-mode -1))

    (if (not (eq system-type 'darwin))
	(setq frame-resize-pixelwise t)) ; proper maximize in some wm

    (if window-system
	(if (eq system-type 'darwin)
	  (set-frame-font "Monaco 13" nil t)
	(set-frame-font "Monospace 13" nil t)))

    ;; without this backspace sends ctrl-h in certain terminals
    (if (not window-system) (normal-erase-is-backspace-mode)))

  (if (daemonp)
      (add-hook 'after-make-frame-functions #'my/init-frame (selected-frame))
    (my/init-frame (selected-frame)))
#+end_src

** kill-region

#+begin_src emacs-lisp
  (defun ts-kill-region (arg)
    "Cut region or current ARG lines to kill ring."
    (interactive "p")
    (let (p1 p2)
      (if (use-region-p)
	(progn (setq p1 (region-beginning))
	       (setq p2 (region-end)))
	(progn (setq p1 (line-beginning-position))
	     (setq p2 (line-beginning-position (+ arg 1)))))
      (kill-region p1 p2)))

  (global-set-key [remap kill-region] 'ts-kill-region)
#+end_src

** kill-ring-save

#+begin_src emacs-lisp
  (defun ts-kill-ring-save (arg)
    "Copy region or current ARG lines to kill ring."
    (interactive "p")
    (let (p1 p2)
      (if (use-region-p)
	(progn (setq p1 (region-beginning))
	       (setq p2 (region-end)))
	(progn (setq p1 (line-beginning-position))
	     (setq p2 (line-beginning-position (+ arg 1)))))
      (kill-ring-save p1 p2)
      (goto-char p2)))

  (global-set-key [remap kill-ring-save] 'ts-kill-ring-save)
#+end_src

** last-buffer

#+begin_src emacs-lisp
  (defun my/last-buffer ()
    "Switch back and forth between two buffers easily."
    (interactive)
    (switch-to-buffer (other-buffer (current-buffer) 1)))

  (keymap-global-set "C-c l" 'my/last-buffer)
  (keymap-global-set "C-<escape>" 'my/last-buffer)
#+end_src

** move-beginning-of-line

#+begin_src emacs-lisp
  (defun my/move-beginning-of-line ()
    "Move point back to indentation. If there is any non blank characters to
  the left of the cursor. Otherwise point moves to beginning of line."
    (interactive)
    (if (= (point) (save-excursion (back-to-indentation) (point)))
	(beginning-of-line)
      (back-to-indentation)))

  (global-set-key [remap move-beginning-of-line] 'my/move-beginning-of-line)
#+end_src

** save-filename

#+begin_src emacs-lisp
  (defun my/save-filename (arg)
    "Save current buffer filename to the kill ring.
  With prefix ARG, omit path."
    (interactive "P")
    (let ((filename (if (equal major-mode 'dired-mode)
		      (if arg
			  (file-name-nondirectory
			   (directory-file-name
			    (file-name-directory default-directory)))
			default-directory)
		    (if arg
			(file-name-nondirectory buffer-file-name)
		      (buffer-file-name)))))
      (when filename
	(kill-new filename)
	(message "Saved '%s' to kill-ring!" filename))))

  (keymap-global-set "C-c f w" 'my/save-filename)
#+end_src

** save-whole-buffer

#+begin_src emacs-lisp
  (defun my/save-whole-buffer ()
    "Save the entire contents of the buffer to the kill ring."
    (interactive)
    (kill-ring-save (point-min) (point-max))
    (message "Saved whole buffer to kill ring :-)"))

  (keymap-global-set "C-x M-w" 'my/save-whole-buffer)
#+end_src

** sudoedit

#+begin_src emacs-lisp
  (defun my/sudoedit (&optional arg)
    "Open current or ARG file as root."
    (interactive "P")
    (if (or arg (not buffer-file-name))
	(find-file (concat "/sudo:root@localhost:"
			 (read-file-name "Find file (as root): ")))
      (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

  (keymap-global-set "C-c f s" 'my/sudoedit)
#+end_src

** toggle-fill

#+begin_src emacs-lisp
  (defun my/toggle-fill ()
    "Like `fill-paragraph', but unfill if used twice."
    (interactive)
    (let ((fill-column
	 (if (eq last-command 'my/toggle-fill)
	     (progn (setq this-command nil)
		    (point-max))
	   fill-column)))
      (call-interactively #'fill-paragraph)))

  (keymap-global-set "M-q" 'my/toggle-fill)
#+end_src

* DIRED

#+begin_src emacs-lisp
  (use-package dired
    :custom
    (delete-by-moving-to-trash t)
    (dired-dwim-target t) ; copy or move into other window
    (dired-listing-switches "-alh")
    (dired-recursive-copies 'always)
    (dired-recursive-deletes 'always)
    :config
    (when (not (eq system-type 'linux)) (setq dired-use-ls-dired 'nil))

    (defun my/dired-up-directory ()
      (interactive)
      (find-alternate-file ".."))

    (defun my/dired-do-delete-skip-trash (&optional arg)
      (interactive "P")
      (let ((delete-by-moving-to-trash nil))
	(dired-do-delete arg)))

    (defun my/dired-get-size ()
      "Get cumlative size of marked or current item."
      (interactive)
      (let ((files (dired-get-marked-files)))
	(with-temp-buffer
	  (apply 'call-process "du" nil t nil "-sch" files)
	  (message "Size of all marked files: %s"
		   (progn
		     (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*total$")
		     (match-string 1))))))

    (defun my/dired-beginning-of-buffer ()
      "Go to first file in directory."
      (interactive)
      (goto-char (point-min))
      (dired-next-line 1))

    (defun my/dired-end-of-buffer ()
      "Go to last file in directory."
      (interactive)
      (goto-char (point-max))
      (dired-next-line -1))

    :bind (:map dired-mode-map
		("," . my/dired-beginning-of-buffer)
		("." . my/dired-end-of-buffer)
		("?" . my/dired-get-size)
		("C-d" . my/dired-do-delete-skip-trash)
		("b" . my/dired-up-directory)
		("f" . 'dired-find-alternate-file))
    :hook
    (dired-mode . dired-omit-mode))
#+end_src

* EWW

#+begin_src emacs-lisp
  (use-package eww
    :custom (eww-search-prefix "https://lite.duckduckgo.com/lite/?q=")
    :bind ("C-c w" . eww))
#+end_src

* FIDO

#+begin_src emacs-lisp
  (use-package icomplete
    :custom
    (fido-vertical-mode t)
    (icomplete-compute-delay 0)
    (completion-auto-help nil))
#+end_src

* FLYSPELL

#+begin_src emacs-lisp
  (use-package flyspell
    :hook
    ((text-mode org-mode) . flyspell-mode)
    (prog-mode . flyspell-prog-mode)
    :bind (:map flyspell-mode-map
		("C-c s w" . flyspell-auto-correct-word)
		("C-c s n" . flyspell-goto-next-error)))
#+end_src

* ISEARCH

#+begin_src emacs-lisp
  (use-package isearch
    :bind (:map isearch-mode-map)
    ("C-c h" . help-command)
    ("C-h" . isearch-delete-char)
    ("C-M-h" . isearch-delete-char))
#+end_src

* LINE NUMBERS

#+begin_src emacs-lisp
  (use-package display-line-numbers
    :custom (display-line-numbers-type 'relative)
    :hook (prog-mode . display-line-numbers-mode))
#+end_src

* LSP

#+begin_src emacs-lisp
  (use-package eglot
    :hook (prog-mode . eglot-ensure)
    :bind (:map eglot-mode-map
		("C-c e r" . eglot-rename)))
  (use-package corfu :ensure
    :custom
    (corfu-cycle t)
    (corfu-auto t)
    :hook (prog-mode . corfu-mode))
#+end_src

* MISC

#+begin_src emacs-lisp
  (use-package recentf :bind ("C-c r" . recentf))
  (use-package savehist :hook (after-init . savehist-mode))
  (use-package which-key :hook (after-init . which-key-mode))
  (use-package whitespace :hook (before-save . whitespace-cleanup))
#+end_src

* ORG

#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-startup-folded t) ; start in overview mode
    (org-goto-interface 'outline-path-completionp)
    (org-outline-path-complete-in-steps nil)
    (org-use-speed-commands t)
    (org-babel-confirm-evaluate nil)
    :config
    ;; stops electric pair from closing > when trying to spawn a src
    ;; block
    (add-to-list 'org-modules 'org-tempo)
    (modify-syntax-entry ?< "." org-mode-syntax-table)
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((shell . t)))
    (setq org-structure-template-alist
	  (append org-structure-template-alist
		  '(("cl" . "src common-lisp")
		    ("el" . "src emacs-lisp")
		    ("go" . "src go")
		    ("kr" . "src c")
		    ("nx" . "src nix")
		    ("py" . "src python")
		    ("sh" . "src shell")
		    ("sq" . "src sql")
		    ("tx" . "src text"))))
    (defun my/tangle-emacs-org-on-save ()
      (interactive)
      (when (string-equal "emacs.org"
			  (file-name-nondirectory
			   (buffer-file-name (current-buffer))))
	(org-babel-tangle)))
    (defun my/compile-and-load-init ()
      (interactive)
      (when (string-equal "init.el"
			  (file-name-nondirectory
			   (buffer-file-name (current-buffer))))
	(byte-compile-file (buffer-file-name (current-buffer)))
	(load (buffer-file-name (current-buffer)))))
    :bind (:map org-mode-map ("C-c i" . org-goto))
    :hook
    (org-mode . auto-fill-mode)
    (after-save . my/tangle-emacs-org-on-save)
    (org-babel-post-tangle . my/compile-and-load-init))
#+end_src

* OUTLINE

#+begin_src emacs-lisp
  (use-package outline
    :custom (outline-minor-mode-cycle t)
    :hook (emacs-lisp-mode . outline-minor-mode))
#+end_src

* SHELL SCRIPT

#+begin_src emacs-lisp
  (use-package sh-script
    :hook (after-save . executable-make-buffer-file-executable-if-script-p))
#+end_src

* TREESIT

https://www.masteringemacs.org/article/how-to-get-started-tree-sitter

Bulk install all the grammars as a one of task, so don't tangle!

#+begin_src emacs-lisp :tangle no
  (setq treesit-language-source-alist
	'((c "https://github.com/tree-sitter/tree-sitter-c")
	  (cpp "https://github.com/tree-sitter/tree-sitter-cpp")
	  (bash "https://github.com/tree-sitter/tree-sitter-bash")
	  (cmake "https://github.com/uyha/tree-sitter-cmake")
	  (css "https://github.com/tree-sitter/tree-sitter-css")
	  (elisp "https://github.com/Wilfred/tree-sitter-elisp")
	  (go "https://github.com/tree-sitter/tree-sitter-go")
	  (html "https://github.com/tree-sitter/tree-sitter-html")
	  (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
	  (json "https://github.com/tree-sitter/tree-sitter-json")
	  (make "https://github.com/alemuller/tree-sitter-make")
	  (markdown "https://github.com/ikatyang/tree-sitter-markdown")
	  (nix "https://github.com/nix-community/tree-sitter-nix")
	  (python "https://github.com/tree-sitter/tree-sitter-python")
	  (ruby "https://github.com/tree-sitter/tree-sitter-ruby")
	  (toml "https://github.com/tree-sitter/tree-sitter-toml")
	  (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
	  (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
	  (yaml "https://github.com/ikatyang/tree-sitter-yaml")))
  (mapc #'treesit-install-language-grammar (mapcar #'car treesit-language-source-alist))
#+end_src

#+begin_src emacs-lisp
  (use-package treesit
    :custom
    (c-ts-mode-indent-style "bsd")
    (major-mode-remap-alist
     '((c-mode . c-ts-mode)
       (c++-mode . c++-ts-mode)
       (css-mode . css-ts-mode)
       (html-mode . html-ts-mode)
       (java-mode . java-ts-mode)
       (js-mode . js-ts-mode)
       (python-mode . python-ts-mode)
       (ruby-mode . ruby-ts-mode)
       (sh-mode . bash-ts-mode)
       (typescript-mode . typescript-ts-mode)))
    :mode
    ("\\.h\\'" . c-ts-mode)
    ("\\Dockerfile\\'" . dockerfile-ts-mode)
    ("\\.go\\'" . go-ts-mode)
    ("\\.json\\'" . json-ts-mode)
    ("\\.lua\\'" . lua-ts-mode)
    ("\\.nix\\'" . nix-ts-mode)
    ("\\.php\\'" . php-ts-mode)
    ("\\.rs\\'" . rust-ts-mode)
    ("\\.yaml\\'" . yaml-ts-mode)
    ("\\.yml\\'" . yaml-ts-mode))
#+end_src

* 3RD PARTY
** ACE WINDOW

#+begin_src emacs-lisp
  (use-package ace-window :ensure
    :bind*
    ("M-o" . ace-window)
    ("M-0" . ace-delete-window)
    ("M-1" . ace-delete-other-windows)
    :config (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
#+end_src

** COPILOT
#+begin_src emacs-lisp
  (use-package copilot :ensure)
  (use-package copilot-chat :ensure
    :custom (copilot-chat-default-model "oswe-vscode-prime")
    :bind ("C-c c" . copilot-chat))
#+end_src
** GIT
#+begin_src emacs-lisp
  (use-package git-timemachine :ensure)
  (use-package magit :ensure :bind* ("C-x g" . magit-status))
  (use-package magit-repos
    :bind* ("C-c g" . magit-list-repositories)
    :custom
    (magit-repository-directories `(("~" . 2)))
    (magit-repolist-columns
     '(("Flag" 5 magit-repolist-column-flags ((:right-align t) nil))
       ("Name" 20 magit-repolist-column-ident nil)
       ("Branch" 10 magit-repolist-column-branch nil)
       ("Pull" 5 magit-repolist-column-unpulled-from-upstream ((:right-align t) nil))
       ("Push" 5 magit-repolist-column-unpushed-to-upstream ((:right-align t) nil))
       ("Path" 99 magit-repolist-column-path nil))))
#+end_src
** HUNGRY DELETE
#+begin_src emacs-lisp
  (use-package hungry-delete :ensure :demand
    :init (global-hungry-delete-mode)
    :custom (hungry-delete-join-reluctantly t))
#+end_src
** PATH FROM SHELL
#+begin_src emacs-lisp
  (use-package exec-path-from-shell :ensure
    :hook (after-init . exec-path-from-shell-initialize))
#+end_src
** VTERM
#+begin_src emacs-lisp
  (use-package vterm :ensure
    :bind* ("C-c t" . vterm)
    :bind (:map vterm-mode-map
		;; USE CTRL-I FFS or the sake of your pinkies!
		("<tab>" . (lambda () (interactive) (message roland)))
		;; USE CTRL-J/M FFS or the sake of your pinkies!
		("<return>" . (lambda () (interactive) (message roland)))
		;; USE CTRL-H FFS or the sake of your pinkies!
		("<backspace>" . (lambda () (interactive) (message roland)))
		("C-h" . (lambda () (interactive) (vterm-send-key "<backspace>")))
		("C-M-h" . (lambda () (interactive) (vterm-send-key "w" nil nil t)))
		("C-u" . (lambda () (interactive) (vterm-send-key "u" nil nil t)))))
#+end_src
** VUNDO
#+begin_src emacs-lisp
  (use-package vundo :ensure :bind* ("C-c u" . vundo))
#+end_src
