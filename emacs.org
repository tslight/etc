#+TITLE: Eight Megabytes And Constantly Swapping
#+PROPERTY: header-args: emacs-lisp :lexical t
#+PROPERTY: header-args+ :cache yes :comments yes :mkdirp yes :results silent
#+PROPERTY: header-args+ :tangle (expand-file-name "init.el" user-emacs-directory)
#+PROPERTY: header-args+ :tangle-mode (identity #o644)

To install, open this file in *Emacs 29+* & evaluate the code block below by
placing the cursor in between the =#+begin_src= & =#+end_src= lines and
pressing =C-c C-c=.

#+begin_src emacs-lisp :tangle no
  (org-babel-tangle) (load (expand-file-name "init.el" user-emacs-directory))
#+end_src

This will "tangle" all the code blocks below /(that don't live under a heading
that starts with =COMMENT=)/ into =~/.emacs.d/init.el= and then compile &
evaluate it.

To un/comment a heading - move the point to the heading and press =C-c ;=.

#+begin_src emacs-lisp :comments no
  ;; -*- lexical-binding: t; -*-
#+end_src

* EMACS

#+begin_src emacs-lisp
  (setq inhibit-startup-screen t)
  (setq initial-scratch-message nil)
  (setq initial-major-mode 'fundamental-mode)

  (setq c-default-style "bsd")
  (setq completion-styles '(basic substring initials flex))
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (setq disabled-command-function nil)
  (setq fill-column 79)

  (setq package-archives
        '(("gnu" . "https://elpa.gnu.org/packages/")
    	("melpa" . "https://melpa.org/packages/")
    	("nongnu" . "https://elpa.nongnu.org/nongnu/")))

  (setq savehist-additional-variables '(compile-command kill-ring register-alist))

  ;; https://emacs.stackexchange.com/a/78660
  (setq tramp-allow-unsafe-temporary-files t)

  (setq use-package-always-defer t)
  (setq use-package-enable-imenu-support t)
  (setq use-short-answers t)
#+end_src

* BINDINGS

#+begin_src emacs-lisp
  (keyboard-translate ?\C-h ?\C-?) ;; act like the terminal
  (define-key key-translation-map (kbd "C-M-h") (kbd "M-DEL"))
  (keymap-global-set "C-c h" 'mark-defun) ;; originally on C-M-h
  (keymap-global-set "M-%" 'query-replace-regexp)
  (keymap-global-set "M-*" 'duplicate-line)
  (keymap-global-set "C-;" 'comment-line)
  (keymap-global-set "C-M-;" 'comment-box)
  (keymap-global-set "C-^" 'copy-from-above-command)
  (keymap-global-set "C-z" 'zap-up-to-char)
  (keymap-global-set "C-c f r" 'rename-visited-file)
  (keymap-global-set "C-c a" 'align-regexp)
  (keymap-global-set "C-c b" 'browse-url-at-point)
  (keymap-global-set "C-c i" 'imenu)
  (keymap-global-set "C-c m" 'man) ;; run sudo makewhatis or mandb
  (keymap-global-set "C-c p" 'proced)
  (keymap-global-set "<f5>" 'compile)
  (keymap-global-set "<f11>" 'toggle-frame-fullscreen)
  (keymap-global-set "C-x C-b" 'switch-to-buffer) ;; DWIW!
  (keymap-global-set "C-x M-b" 'ibuffer)
  (keymap-global-set "C-x x s" 'sort-lines)
  (keymap-global-set "C-x M-k" 'kill-buffer)
  (keymap-global-set "C-x M-c" 'kill-emacs) ;; for killing the daemon
  (keymap-global-set "C-x k" #'(lambda () (interactive) (kill-buffer (current-buffer))))
#+end_src

* DEFUNS

All of my custom functions live under the =my/= prefix/namespace.

** delete-inside-delimiters

#+begin_src emacs-lisp
  (defun my/delete-inside-delimiters (arg)
    "Deletes the text within parentheses, brackets or quotes. With prefix
  ARG, delete delimiters too."
    (interactive "P")
    ;; Search for a match on the same line, don't delete across lines
    (search-backward-regexp "[[{(<\"\']" (line-beginning-position))
    (forward-char)
    (let ((lstart (point)))
      (search-forward-regexp "[]})>\"\']" (line-end-position))
      (backward-char)
      (if arg
          (kill-region (- lstart 1) (+ (point) 1))
        (kill-region lstart (point)))))

  (keymap-global-set "C-c d" 'my/delete-inside-delimiters)
#+end_src

** delete-this-file

#+begin_src emacs-lisp
  (defun my/delete-this-file ()
    "Delete the current file, and kill the buffer."
    (interactive)
    (or (buffer-file-name) (error "No file is currently being edited"))
    (when (yes-or-no-p (format "Really delete '%s'?"
                               (file-name-nondirectory buffer-file-name)))
      (delete-file (buffer-file-name) t)
      (kill-this-buffer)))

  (keymap-global-set "C-c f d" 'my/delete-this-file)
#+end_src

** indent-buffer

#+begin_src emacs-lisp
  (defun my/indent-buffer ()
    "Indent the contents of a buffer."
    (interactive)
    (indent-region (point-min) (point-max)))

  (keymap-global-set "M-i" 'my/indent-buffer)
#+end_src

** init-frame

Otherwise emacsclient doesn't initialise UI settings.

#+begin_src emacs-lisp
  (defun my/init-frame (frame)
    "Initialize frame UI, and settings that don't work unless they're set
  after emacsclient has created a frame"
    (select-frame frame)

    (if window-system (load-theme 'modus-vivendi))

    (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
    (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
    (if (fboundp 'tooltip-mode) (tooltip-mode -1))

    (when (not (eq system-type 'darwin)) (menu-bar-mode -1))

    (if (not (eq system-type 'darwin))
        (setq frame-resize-pixelwise t)) ; proper maximize in some wm

    (if window-system
        (if (eq system-type 'darwin)
            (set-frame-font "Monaco 13" nil t)
  	(set-frame-font "Monospace 13" nil t)))
    
    (normal-erase-is-backspace-mode))

  (if (daemonp)
      (add-hook 'after-make-frame-functions #'my/init-frame (selected-frame))
    (my/init-frame (selected-frame)))
#+end_src

** emacs-startup

#+begin_src emacs-lisp
  (defun my/emacs-startup ()
    "Expensive stuff to make sure we don't run until after Emacs starts"
    
    (column-number-mode)

    (setq display-time-default-load-average 'nil)
    (setq display-time-format "%H:%M %a %d/%m")
    (display-battery-mode)
    (display-time)

    (electric-pair-mode)
    (global-subword-mode)
    (global-prettify-symbols-mode)
    (save-place-mode 1)

    (cond ((executable-find "chrome") (setq default-browser "chrome"))
          ((executable-find "firefox") (setq default-browser "firefox"))
          ((executable-find "librewolf") (setq default-browser "librewolf")))
    (setq browse-url-browser-function 'browse-url-generic
          browse-url-generic-program default-browser)

    (when (executable-find "fd") find-program "fd")
    (when (executable-find "rg") grep-program "rg"))

  (add-hook 'emacs-startup-hook #'my/emacs-startup)
#+end_src

** kill-region

#+begin_src emacs-lisp
  (defun ts-kill-region (arg)
    "Cut region or current ARG lines to kill ring."
    (interactive "p")
    (let (p1 p2)
      (if (use-region-p)
        (progn (setq p1 (region-beginning))
               (setq p2 (region-end)))
        (progn (setq p1 (line-beginning-position))
             (setq p2 (line-beginning-position (+ arg 1)))))
      (kill-region p1 p2)))

  (global-set-key [remap kill-region] 'ts-kill-region)
#+end_src

** kill-ring-save

#+begin_src emacs-lisp
  (defun ts-kill-ring-save (arg)
    "Copy region or current ARG lines to kill ring."
    (interactive "p")
    (let (p1 p2)
      (if (use-region-p)
        (progn (setq p1 (region-beginning))
               (setq p2 (region-end)))
        (progn (setq p1 (line-beginning-position))
             (setq p2 (line-beginning-position (+ arg 1)))))
      (kill-ring-save p1 p2)
      (goto-char p2)))

  (global-set-key [remap kill-ring-save] 'ts-kill-ring-save)
#+end_src

** last-buffer

#+begin_src emacs-lisp
  (defun my/last-buffer ()
    "Switch back and forth between two buffers easily."
    (interactive)
    (switch-to-buffer (other-buffer (current-buffer) 1)))

  (keymap-global-set "C-c l" 'my/last-buffer)
  (keymap-global-set "C-<escape>" 'my/last-buffer)
#+end_src

** move-beginning-of-line

#+begin_src emacs-lisp
  (defun my/move-beginning-of-line ()
    "Move point back to indentation. If there is any non blank characters to
  the left of the cursor. Otherwise point moves to beginning of line."
    (interactive)
    (if (= (point) (save-excursion (back-to-indentation) (point)))
        (beginning-of-line)
      (back-to-indentation)))

  (global-set-key [remap move-beginning-of-line] 'my/move-beginning-of-line)
#+end_src

** save-filename

#+begin_src emacs-lisp
  (defun my/save-filename (arg)
    "Save current buffer filename to the kill ring.
  With prefix ARG, omit path."
    (interactive "P")
    (let ((filename (if (equal major-mode 'dired-mode)
                      (if arg
                          (file-name-nondirectory
                           (directory-file-name
                            (file-name-directory default-directory)))
                        default-directory)
                    (if arg
                        (file-name-nondirectory buffer-file-name)
                      (buffer-file-name)))))
      (when filename
        (kill-new filename)
        (message "Saved '%s' to kill-ring!" filename))))

  (keymap-global-set "C-c f w" 'my/save-filename)
#+end_src

** save-whole-buffer

#+begin_src emacs-lisp
  (defun my/save-whole-buffer ()
    "Save the entire contents of the buffer to the kill ring."
    (interactive)
    (kill-ring-save (point-min) (point-max))
    (message "Saved whole buffer to kill ring :-)"))

  (keymap-global-set "C-x M-w" 'my/save-whole-buffer)
#+end_src

** sudo shenanigans

#+begin_src emacs-lisp
  (defun my/sudoedit ()
    "Re-open current file as root."
    (interactive)
    (find-alternate-file (concat "/sudo::" buffer-file-name)))

  (defun my/sudo-find-file (file-name)
    "Like find file, but opens the file as root."
    (interactive "FFind file (as root): ")
    (find-file (concat "/sudo::" file-name)))

  (keymap-global-set "C-c f s" 'my/sudoedit)
  (keymap-global-set "C-x M-f" 'my/sudo-find-file)
#+end_src

** toggle-fill

#+begin_src emacs-lisp
  (defun my/toggle-fill ()
    "Like `fill-paragraph', but unfill if used twice."
    (interactive)
    (let ((fill-column
         (if (eq last-command 'my/toggle-fill)
             (progn (setq this-command nil)
                    (point-max))
           fill-column)))
      (call-interactively #'fill-paragraph)))

  (keymap-global-set "M-q" 'my/toggle-fill)
#+end_src

* DIRED

#+begin_src emacs-lisp
  (use-package dired
    :custom
    (delete-by-moving-to-trash t)
    (dired-dwim-target t) ; copy or move into other window
    (dired-listing-switches "-alh")
    (dired-recursive-copies 'always)
    (dired-recursive-deletes 'always)
    :config
    (when (not (eq system-type 'linux)) (setq dired-use-ls-dired 'nil))

    (defun my/dired-up-directory ()
      (interactive)
      (find-alternate-file ".."))

    (defun my/dired-do-delete-skip-trash (&optional arg)
      (interactive "P")
      (let ((delete-by-moving-to-trash nil))
        (dired-do-delete arg)))

    (defun my/dired-get-size ()
      "Get cumlative size of marked or current item."
      (interactive)
      (let ((files (dired-get-marked-files)))
        (with-temp-buffer
        (apply 'call-process "du" nil t nil "-sch" files)
        (message "Size of all marked files: %s"
                 (progn
                   (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*total$")
                   (match-string 1))))))

    (defun my/dired-beginning-of-buffer ()
      "Go to first file in directory."
      (interactive)
      (goto-char (point-min))
      (dired-next-line 1))

    (defun my/dired-end-of-buffer ()
      "Go to last file in directory."
      (interactive)
      (goto-char (point-max))
      (dired-next-line -1))

    :bind (:map dired-mode-map
              ("," . my/dired-beginning-of-buffer)
              ("." . my/dired-end-of-buffer)
              ("?" . my/dired-get-size)
              ("C-d" . my/dired-do-delete-skip-trash)
              ("b" . my/dired-up-directory)
              ("f" . 'dired-find-alternate-file))
    :hook
    (dired-mode . dired-omit-mode))
#+end_src

* LINE NUMBERS

#+begin_src emacs-lisp
  (use-package display-line-numbers
    :custom (display-line-numbers-type 'relative)
    :hook (prog-mode . display-line-numbers-mode))
#+end_src

* MISC

#+begin_src emacs-lisp
  (use-package recentf :bind ("C-c r" . recentf))
  (use-package savehist :hook (emacs-startup . savehist-mode))
  (use-package which-key :hook (emacs-startup . which-key-mode))
  (use-package whitespace :bind ("C-c w" . whitespace-cleanup))
#+end_src

* ORG

#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-startup-folded t) ; start in overview mode
    (org-goto-interface 'outline-path-completionp)
    (org-outline-path-complete-in-steps nil)
    (org-use-speed-commands t)
    (org-babel-confirm-evaluate nil)
    :config
    ;; stops electric pair from closing > when trying to spawn a src
    ;; block
    (add-to-list 'org-modules 'org-tempo)
    (modify-syntax-entry ?< "." org-mode-syntax-table)
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((shell . t)))
    (setq org-structure-template-alist
        (append org-structure-template-alist
                '(("cl" . "src common-lisp")
                  ("el" . "src emacs-lisp")
                  ("go" . "src go")
                  ("kr" . "src c")
                  ("nx" . "src nix")
                  ("py" . "src python")
                  ("sh" . "src shell")
                  ("sq" . "src sql")
                  ("tx" . "src text"))))
    (defun my/tangle-emacs-org-on-save ()
      (interactive)
      (when (string-equal "emacs.org"
                        (file-name-nondirectory
                         (buffer-file-name (current-buffer))))
        (org-babel-tangle)))
    (defun my/compile-and-load-init ()
      (interactive)
      (when (string-equal "init.el"
                        (file-name-nondirectory
                         (buffer-file-name (current-buffer))))
        (byte-compile-file (buffer-file-name (current-buffer)))
        (load (buffer-file-name (current-buffer)))))
    :bind (:map org-mode-map ("C-c i" . org-goto))
    :hook
    (org-mode . auto-fill-mode)
    (after-save . my/tangle-emacs-org-on-save)
    (org-babel-post-tangle . my/compile-and-load-init))
#+end_src

* SHELL SCRIPT

#+begin_src emacs-lisp
  (use-package sh-script
    :hook (after-save . executable-make-buffer-file-executable-if-script-p))
#+end_src

* TREESIT

https://www.masteringemacs.org/article/how-to-get-started-tree-sitter

Bulk install all the grammars as a one of task, so don't tangle!

#+begin_src emacs-lisp :tangle no
  (setq treesit-language-source-alist
        '((c "https://github.com/tree-sitter/tree-sitter-c")
        (cpp "https://github.com/tree-sitter/tree-sitter-cpp")
        (bash "https://github.com/tree-sitter/tree-sitter-bash")
        (cmake "https://github.com/uyha/tree-sitter-cmake")
        (css "https://github.com/tree-sitter/tree-sitter-css")
        (elisp "https://github.com/Wilfred/tree-sitter-elisp")
        (go "https://github.com/tree-sitter/tree-sitter-go")
        (html "https://github.com/tree-sitter/tree-sitter-html")
        (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
        (json "https://github.com/tree-sitter/tree-sitter-json")
        (lua "https://github.com/tree-sitter-grammars/tree-sitter-lua")
        (make "https://github.com/alemuller/tree-sitter-make")
        (markdown "https://github.com/ikatyang/tree-sitter-markdown")
        (nix "https://github.com/nix-community/tree-sitter-nix")
        (python "https://github.com/tree-sitter/tree-sitter-python")
        (ruby "https://github.com/tree-sitter/tree-sitter-ruby")
        (toml "https://github.com/tree-sitter/tree-sitter-toml")
        (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
        (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
        (yaml "https://github.com/ikatyang/tree-sitter-yaml")))
  (mapc #'treesit-install-language-grammar (mapcar #'car treesit-language-source-alist))
#+end_src

#+begin_src emacs-lisp
  (use-package treesit
    :custom
    (c-ts-mode-indent-style "bsd")
    (major-mode-remap-alist
     '((c-mode . c-ts-mode)
       (c++-mode . c++-ts-mode)
       (css-mode . css-ts-mode)
       (html-mode . html-ts-mode)
       (java-mode . java-ts-mode)
       (js-mode . js-ts-mode)
       (python-mode . python-ts-mode)
       (ruby-mode . ruby-ts-mode)
       (sh-mode . bash-ts-mode)
       (typescript-mode . typescript-ts-mode)))
    :mode
    ("\\.h\\'" . c-ts-mode)
    ("\\Dockerfile\\'" . dockerfile-ts-mode)
    ("\\.go\\'" . go-ts-mode)
    ("\\.json\\'" . json-ts-mode)
    ("\\.lua\\'" . lua-ts-mode)
    ("\\.nix\\'" . nix-ts-mode)
    ("\\.php\\'" . php-ts-mode)
    ("\\.rs\\'" . rust-ts-mode)
    ("\\.yaml\\'" . yaml-ts-mode)
    ("\\.yml\\'" . yaml-ts-mode))
#+end_src

* 3RD PARTY

** GIT TIMEMACHINE

#+begin_src emacs-lisp
  (use-package git-timemachine :ensure)
#+end_src

** HUNGRY DELETE

#+begin_src emacs-lisp
  (use-package hungry-delete :ensure
    :custom (hungry-delete-join-reluctantly t)
    :hook (emacs-startup . global-hungry-delete-mode))
#+end_src

** VUNDO

#+begin_src emacs-lisp
  (use-package vundo :ensure :bind* ("C-c u" . vundo))
#+end_src

** XCLIP

#+begin_src emacs-lisp
  (when (and (not window-system) (executable-find "xclip"))
    (use-package xclip :ensure :hook (emacs-startup . xclip-mode)))
#+end_src
